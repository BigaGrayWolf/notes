# 算法总结

从二叉树刷起

## 二叉树

基本框架

```cpp
void traverse(TreeNode root) {
// vist(root)   前序遍历
traverse(root.left)
// vist(root)   中序遍历
traverse(root.right)
// vist(root)   后序遍历
}

```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

```cpp
class Solution {
public:
    int core(TreeNode* root){//core返回以root为尾的一条路径的最大和
        if(root==nullptr)
            return 0;
        int left=max(0,core(root->left));
        int right=max(0,core(root->right));
        ans=max(ans,left+right+root->val);
        return max(left,right)+root->val;
    }
    int maxPathSum(TreeNode* root) {
        core(root);
        return ans;
    }
private:
    int ans=INT_MIN;
};
```

用一个后续遍历解决。

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

递归加上前序遍历

```cpp
class Solution {
public:
    TreeNode* core(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart,int inEnd){
        if(preStart>preEnd||inStart>inEnd)
            return nullptr;
        TreeNode* root=new TreeNode(preorder[preStart]);
        int inroot=inStart;
        while(preorder[preStart]!=inorder[inroot])
            inroot++;
        int lsize=inroot-inStart;
        root->left=core(preorder,preStart+1,preStart+lsize,inorder,inStart,inroot-1);//递归构建左子树
        root->right=core(preorder,preStart+lsize+1,preEnd,inorder,inroot+1,inEnd);//递归构建右子树
        return root;

    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty())
            return nullptr;
        TreeNode* root=core(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1);
        return root;
    }
};
```

#### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

中序遍历

```cpp
class Solution {
public:
    void inorder(TreeNode* root,TreeNode*& pre){
        if(root==nullptr)
            return;
        inorder(root->left,pre);
        if(pre==nullptr)
            pre=root;
        if(root->val<pre->val){  //当满足a[i]<a[i-1]时，记录下这个节点位置
            s=(s==nullptr)?pre:s;  //对于第一个位置记录下i-1
            t=root;					//第二个位置距离i
        }
        pre=root;
        inorder(root->right,pre);
    }
    void recoverTree(TreeNode* root) {
        TreeNode* pre=nullptr;
        inorder(root,pre);
        swap(s->val,t->val);  //交换两个位置的值
    }
private:
    TreeNode* s;
    TreeNode* t;
};
```

一颗BST树的两个节点被错误交换会使得它的中序遍历结果中有两个位置满足a[i]<a[i-1],如果被交换的两个节点相邻的话那只有一个位置满足a[i]<a[i-1]

所以只要找到这两个位置，交换他们的值即可。

#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

```cpp
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        ostringstream out;
        queue<TreeNode*> Q;
        Q.push(root);
        while(!Q.empty()){  //对二叉树进行层次遍历，输出到string中
            TreeNode* tmp=Q.front();
            Q.pop();
            if(tmp==nullptr){
                out<<"$ ";
                continue;
            }
            out<<to_string(tmp->val)<<" ";
            Q.push(tmp->left);
            Q.push(tmp->right);
        }
        return out.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        istringstream input(data);
        string val;
        vector<TreeNode*> vec;
        while(input>>val){   //将层次遍历的结果string保存在一个vector中
            if(val=="$")
                vec.push_back(nullptr);
            else{
                vec.push_back(new TreeNode(stoi(val)));
            }
        }
        int j=1;
        for(int i=0;j<vec.size();i++){  //遍历vector中的每个节点，根据层次遍历的规律指定其左子树和右子树。
            if(vec[i]!=nullptr){
                vec[i]->left=vec[j++];
                vec[i]->right=vec[j++];
            }     
        }
        return vec[0];
    }
};
```

#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```cpp
class Solution {
public:
    TreeNode* core(vector<int>& nums,int start,int end){
        if(start>end)
            return nullptr;
        int index=start;
        for(int i=start+1;i<=end;i++){
            if(nums[i]>nums[index])
                index=i;
        }
        TreeNode* root=new TreeNode(nums[index]);
        root->left=core(nums,start,index-1);
        root->right=core(nums,index+1,end);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* root=core(nums,0,nums.size()-1);
        return root;
    }
};
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```cpp
class Solution {
public:
    TreeNode* core(int inStart,int inEnd,int posStart,int posEnd){
        if(inStart>inEnd||posStart>posEnd)
            return nullptr;
        int index=inStart;
        while(inorder[index]!=postorder[posEnd])
            index++;
        TreeNode* root=new TreeNode(postorder[posEnd]);
        int right_len=inEnd-index;
        root->right=core(index+1,inEnd,posEnd-right_len,posEnd-1);
        root->left=core(inStart,index-1,posStart,posEnd-right_len-1);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        this->inorder=inorder;
        this->postorder=postorder;
        TreeNode* root=core(0,inorder.size()-1,0,postorder.size()-1);
        return root;
    }
private:
    vector<int> inorder;
    vector<int> postorder;
};
```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```c++
class Solution {
public:
    void core(Node* node1,Node* node2){
        if(node1==nullptr)
            return;
        node1->next=node2;
        core(node1->left,node1->right);
        core(node2->left,node2->right);
        core(node1->right,node2->left);
    }
    Node* connect(Node* root) {
        if(root==nullptr)
            return root;
        core(root->left,root->right);
        return root;
    }
};
```

#### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

方法一：层次遍历

![image-20200928111259690](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200928111259690.png)

```c++
class Solution {
public:
    void handle(Node* &last, Node* &p, Node* &nextStart) {
        if (last) {
            last->next = p;
        } 
        if (!nextStart) {
            nextStart = p;
        }
        last = p;
    }

    Node* connect(Node* root) {
        if (!root) {
            return nullptr;
        }
        Node *start = root;
        while (start) {
            Node *last = nullptr, *nextStart = nullptr;
            for (Node *p = start; p != nullptr; p = p->next) {
                if (p->left) {
                    handle(last, p->left, nextStart);
                }
                if (p->right) {
                    handle(last, p->right, nextStart);
                }
            }
            start = nextStart;
        }
        return root;
    }
};
```



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if(root==nullptr)
            return;
        flatten(root->left);
        flatten(root->right);
        TreeNode* left=root->left;
        TreeNode* right=root->right;
        root->left=nullptr;
        root->right=left;
        while(root->right!=nullptr)
            root=root->right;
        root->right=right;
    }
};
```

#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

我们递归遍历整棵二叉树，定义$f$$x$ 表示 $x$节点的子树中是否包含 $p$节点或 $q$ 节点，如果包含为 $true$，否则为 $false$。那么符合条件的最近公共祖先 $x$ 一定满足如下条件：

![image-20201009220139482](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20201009220139482.png)

```c++
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return false;
        bool lson = dfs(root->left, p, q);
        bool rson = dfs(root->right, p, q);
        if ((lson && rson) || ((root->val == p->val || root->val == q->val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root->val == p->val || root->val == q->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root, p, q);
        return ans;
    }
};
```

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

## 凑零钱问题

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,amount+1);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            for(int j=0;j<coins.size();j++){
                if(coins[j]<=i){
                    dp[i]=min(dp[i-coins[j]]+1,dp[i]);
                }
            }
        }
        return dp[amount]>amount?-1:dp[amount];
           
    }
};
```

- 先确定「状态」，也就是原问题和⼦问题中变化的变量。由于硬币数量⽆ 限，所以唯⼀的状态就是⽬标⾦额 amount 。
- 然后确定 dp 函数的定义：当前的⽬标⾦额是 n ，⾄少需要 dp(n) 个硬 币凑出该⾦额。 
- 然后确定「选择」并择优，也就是对于每个状态，可以做出什么选择改变当 前状态。具体到这个问题，⽆论当的⽬标⾦额是多少，选择就是从⾯额列表 coins 中选择⼀个硬币，然后⽬标⾦额就会减少：

```python
# 伪码框架
def coinChange(coins: List[int], amount: int):
	# 定义：要凑出⾦额 n，⾄少要 dp(n) 个硬币
	def dp(n):
		# 做选择，选择需要硬币最少的那个结果
		for coin in coins:
			res = min(res, 1 + dp(n - coin))
		return res
	# 我们要求的问题是 dp(amount)
	return dp(amount)

```

- 最后明确 base case，显然⽬标⾦额为 0 时，所需硬币数量为 0.

## 回溯算法

**解决⼀个回溯问题，实际上就是⼀个决策树的遍历过程。**

1. 路径：也就是已经做出的选择。 
2. 选择列表：也就是你当前可以做的选择。 
3. 结束条件：也就是到达决策树底层，⽆法再做选择的条件。

```python
result = []
def backtrack(路径, 选择列表):
	if 满⾜结束条件:
		result.add(路径)
		return
	for 选择 in 选择列表:
		做选择
		backtrack(路径, 选择列表)
		撤销选择

```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

#### [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```cpp
class Solution {
public:
    bool isvalid(vector<string>& board,int r,int c){
        for(int i=0;i<r;i++){
            if(board[i][c]=='Q')
                return false;
        }
        for(int i=r-1,j=c-1;i>=0&&j>=0;i--,j--){
            if(board[i][j]=='Q')
                return false;
        }
        for(int i=r-1,j=c+1;i>=0&&j<board[0].size();i--,j++){
            if(board[i][j]=='Q')
                return false;
        }
        return true;
    }
    void dfs(vector<string>& board,int row){
        if(row==board.size()){   //满足条件，记录答案并返回
            ret.push_back(board);
            return;
        }
        for(int j=0;j<board[row].size();j++){
            if(isvalid(board,row,j)){
                board[row][j]='Q';  //做选择
                dfs(board,row+1);  //dfs遍历
                board[row][j]='.'; //撤销选择
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> board(n,string(n,'.'));
        dfs(board,0);
        return ret;

    }
private:
    vector<vector<string>> ret;
    
};
```

#### [486. 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)

```cpp
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        int n=nums.size();
        vector<vector<int>> dp(n,vector<int>(n,0));
        for(int i=0;i<n;i++)
            dp[i][i]=nums[i];
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                dp[i][j]=max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);
            }
        }
        return dp[0][n-1]>=0;       
    }
};
```



## BFS

```cpp
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
	Queue<Node> q; // 核⼼数据结构
	Set<Node> visited; // 避免⾛回头路
	q.offer(start); // 将起点加⼊队列
	visited.add(start);
	int step = 0; // 记录扩散的步数
	while (q not empty) {
		int sz = q.size();
		/* 将当前队列中的所有节点向四周扩散 */
		for (int i = 0; i < sz; i++) {
			Node cur = q.poll();
			/* 划重点：这⾥判断是否到达终点 */
    		if (cur is target)
				return step;
			/* 将 cur 的相邻节点加⼊队列 */
		for (Node x : cur.adj())
			if (x not in visited) {
				q.offer(x);
				visited.add(x);
			}
	}
	/* 划重点：更新步数在这⾥ */
	step++;
	}
}

```

#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

#### [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

## 二分查找框架

### 寻找一个数

#### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```cpp
int binarySearch(int[] nums, int target) {
	int left = 0;
	int right = nums.length - 1; // 注意
	while(left <= right) {
		int mid = left + (right - left) / 2;
		if(nums[mid] == target)
			return mid;
		else if (nums[mid] < target)
			left = mid + 1; // 注意
		else if (nums[mid] > target)
			right = mid - 1; // 注意
	}
	return -1;
}
```

当初始化 right 的赋值是 nums.length - 1 ，即最后⼀个元素的索 引。搜索区间为[left,right]为闭区间，所以while中为<=号。

left的更新为mid+1，right的更新为mid-1；

当初始化 right 的赋值是 nums.length 。搜索区间为[left,right)为左开右闭，while中应该<号。

left的更新为mid+1，right的更新为mid；

### 寻找左侧边界的⼆分搜索

```cpp
int left_bound(int[] nums, int target) {
	if (nums.length == 0) return -1;
	int left = 0;
	int right = nums.length; // 注意
	while (left < right) { // 注意
		int mid = (left + right) / 2;
		if (nums[mid] == target) {
			right = mid;
		} 
        else if (nums[mid] < target) {
			left = mid + 1;
		}
        else if (nums[mid] > target) {
			right = mid; // 注意
		}
	}
    // target ⽐所有数都⼤
	if (left == nums.length) return -1;
	// 类似之前算法的处理⽅式
	return nums[left] == target ? left : -1; // target ⽐所有数都小
	return left;
}
```

### 寻找右侧边界的⼆分查找

```cpp
int right_bound(int[] nums, int target) {
	if (nums.length == 0) return -1;
	int left = 0, right = nums.length;
	while (left < right) {
		int mid = (left + right) / 2;
		if (nums[mid] == target) {
			left = mid + 1; // 注意
		} 
        else if (nums[mid] < target) {
			left = mid + 1;
		}
        else if (nums[mid] > target) {
			right = mid;
		}
	}	
	if (left == 0) return -1;
	return nums[left-1] == target ? (left-1) : -1;  //因为nums[mid] == target时left被更新为了mid+1，所以这里要返回left-1；
}

```

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

#### [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)



## 滑动窗口

```cpp
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++; //注意这里，right已经+1了
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) 
                    valid++;
            }
            // 判断左侧窗口是否要收缩
            while (right - left >= t.size()) {  //所以这里长度时right-left不用加1
                // 当窗口符合条件时，把起始索引加入 res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }
};
```

## 动态规划

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int n=s.size();
        vector<int> dp(n,0);
        int ans=0;
        for(int i=1;i<n;i++){
            if(s[i]==')'&&s[i-1]=='(')
                dp[i]=i>=2?dp[i-2]+2:2;
            else if(s[i]==')'&&s[i-1]==')'){
                if(i-dp[i-1]>0&&s[i-dp[i-1]-1]=='(')
                    dp[i]=dp[i-1]+((i-dp[i-1])>=2?dp[i-dp[i-1]-2]:0)+2;
            }
            ans=max(ans,dp[i]);   
        }
        return ans;
    }
};
```

动态规划解法：

规定$dp[i]$为以下标$i$的字符为结尾的最长有效括号长度。初始化为0，显然有效子串一定是以')'为结尾。此时分两种情况

1. 当$s[i]=')'$并且$s[i-1]='('$时

   ​														$dp[i]=dp[i−2]+2$

2. 当$s[i]='('$并且$s[i-1]='('$时，也就是形如”........))“,我们可以推

   如果$s[i-dp[i-1]-1]='('$  那么

   ​																		$dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2$

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> S;
        S.push(-1); //先放一个-1，表示最初未匹配的右括号
        int ans=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(')
                S.push(i);
            else{
                S.pop(); //弹出栈顶，表示和当前')'做匹配
                if(S.empty()){ //如果栈为空，表示当前')'没有可匹配的左括号，将其下标入栈
                    S.push(i);
                }
                else{
                    ans=max(ans,i-S.top()); //否则i-S.top()为以当前右括号为结尾的最长有效括号的长度
                }
            }

        }
        return ans;
    }
};
```

使用栈的解法：

**始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」**，这样的做法主要是考虑了边界条件的处理，**栈里其他元素维护左括号的下标：**

对于遇到的每个’(‘，将它的下标放入栈中
对于遇到的每个')'，先弹出栈顶元素表示匹配了当前右括号：
如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，**我们在一开始的时候往栈中放入一个值为 -1 的元素。**

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        stack<int> S;
        S.push(-1);
        int ans=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(')
                S.push(i);
            else{
                S.pop();
                if(S.empty()){
                    S.push(i);
                }
                else{
                    ans=max(ans,i-S.top());
                }
            }

        }
        return ans;
    }
};
```



#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

用$dp[i][j]$表示使用前$i$个数组能否凑出河为j的可能性

则$dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i]]$

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.empty())
            return true;
        int sum=0;
        for(int n:nums) sum+=n;
        if(sum%2) return false;
        sum/=2;
        vector<bool> dp(sum+1,false);
        dp[0]=true;
        for(int i=0;i<nums.size();i++){
            for(int j=sum;j>=0;j--){
                if(j>=nums[i])
                    dp[j]=dp[j]||dp[j-nums[i]];
            }
        }
        return dp[sum];
        
    }
};
```



## 链表

#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head==nullptr)
            return;
        int n=0;
        ListNode* cur=head;
        while(cur!=nullptr){
            n++;
            cur=cur->next;
        }
        ListNode* pre=head;
        cur=head->next;
        int mid=0;
        while(mid<n/2){
            pre=pre->next;
            cur=cur->next;
            mid++;
        }
        pre->next=nullptr;
        while(cur!=nullptr){               //先将链表的后半部分翻转
            ListNode* cur_next=cur->next;
            ListNode* pre_next=pre->next;
            pre->next=cur;
            cur->next=pre_next;
            cur=cur_next;
        }
        ListNode* left=head;
        ListNode* right=pre->next;    //得到两个链表，顺序插入就完事
        pre->next=nullptr;
        while(right!=nullptr){
            ListNode* left_next=left->next;
            ListNode* right_next=right->next;
            left->next=right;
            right->next=left_next;
            left=left_next;
            right=right_next;
        }
    }
};
```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

快慢指针

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(head==nullptr)
            return nullptr;
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast!=nullptr&&fast->next!=nullptr){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)
                break;
        }
        if(fast==nullptr||fast->next==nullptr)
            return nullptr;
        slow=head;
        while(slow!=fast){
            slow=slow->next;
            fast=fast->next;
        }
        return slow;
    }
};
```



## 经典问题

### 对浮点数开根号

二分法和牛顿法

```cpp

#include<iostream>
#include<string>
#define PRECISION 0.0002
using namespace std;
 
//二分法
//二分法通过缩小根值范围的方法来逼近结果
float sqrt1(float n) {
	float min, max, mid; //min代表下边界，max代表上边界，mid为中间值也作为近似值
	min = 0;
	max = n;
	mid = n / 2;
	while (mid*mid>n + PRECISION || mid*mid<n - PRECISION)
	{
		mid = (max + min) / 2;
		if (mid*mid < n + PRECISION) {
			min = mid; //根值偏小，升高下边界
		};
		if (mid*mid > n - PRECISION) {
			max = mid;//根值偏大，降低上边界
		}
	}
	return mid;
}
 
//牛顿法
float sqrt2(float n) {
	float k = n;
	while (1) {
		if (k*k > n - PRECISION && k*k < n + PRECISION) {
			break;
		}
		k = 0.5*(k + n/k);//通过牛顿法得出
	}
	return k;
}
int main() {
	float a = 11.283;
	float res1, res2;
	res1 = sqrt1(a);
	res2 = sqrt2(a);
	cout << "num is "<< a << endl;
	cout << "二分法结果: " << res1 << endl;
	cout <<"牛顿法结果: "<< res2 << endl; 
	cout << "二分法验证: " << res1 * res1 << endl;
	cout <<"牛顿法验证: "<<res2 * res2 << endl;
	system("pause");
	return 0;
}
```

对于二分法，看注释就可以看得很明白了。对于牛顿法，有着更简洁的代码，但需要花一点数学思维来理解。其实，直接看牛顿法会对这道题的理解更费解，因为牛顿法的目标并不是为了开根号。 很多博主也不太负责任的直接贴上牛顿法的证明方法，对于读者理解这道题来说反而有误导作用。

牛顿法的目的是求方程的近似解，即函数曲线与横坐标的交点。比如，![f(x)=x^5+2x^2+8](https://private.codecogs.com/gif.latex?f%28x%29%3Dx%5E5&plus;2x%5E2&plus;8)，求f(x)=0时，x的值。

那么这个牛顿法跟开根号有什么关系呢，![f(x)=\sqrt x](https://private.codecogs.com/gif.latex?f%28x%29%3D%5Csqrt%20x)可以转换一个思路，![x = y^2](https://private.codecogs.com/gif.latex?x%20%3D%20y%5E2) ==> ![y^2 - x = 0](https://private.codecogs.com/gif.latex?y%5E2%20-%20x%20%3D%200)

还有点难理解对吧，对于求开方，我们可以确定知道x的值，比如x=67，y=?。

那么上述公式就等价于![f(y) = y^2 - 67](https://private.codecogs.com/gif.latex?f%28y%29%20%3D%20y%5E2%20-%2067)， 求f(y)=0时，y的取值。这样一来就可以转换成牛顿法来解决。我们可以画出f(y)的图像，其实就是f(y)=y^2标准抛物线向下平移67个单位的样子：

![img](https://img-blog.csdn.net/20180922130352938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xldmlvcGt1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上述图像就是x=67时的转换图像，我们要求图像和x轴正半轴的交点(根号值只可能为正)，即上图标出的y点。

![img](https://img-blog.csdn.net/20180922131005981?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xldmlvcGt1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

首先，在x轴右半轴上任意取一点p，p点作垂线求得与曲线的交点，即f(p)，如上述黑线所示，p点未标出(就是y点左边那个交点)。

求出f(p)之后，再对点（p, f(p)）作一条切线，这条切线务必与x轴有一个交点(这个交点比p更接近y)。

我们可以用同样的方法对这个交点操作一遍(如红线所示)，那么新交点一定会更接近y。取最后一个epoch的取值当作y的近似值。

那么，就可以建立一种数学联系。

设第一个点为(p1,0)，则其垂线与曲线交点为f(p1)，则切点为(p1, f(p1))，切线斜率为f '(p1)，知道斜率和一个确定点，就可以确定这条直线(切线)，那么自然可以求得这条切线与x轴的交点(p2,0)。以此来确定，p2和p1之间的对应关系，这种对应关系可以泛化到p_{n+1}对pn的对应关系。

可以简单推一推：

![img](https://img-blog.csdn.net/20180922132919103?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xldmlvcGt1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上面得出![p_{n+1}](https://private.codecogs.com/gif.latex?p_%7Bn&plus;1%7D)比![p_n](https://private.codecogs.com/gif.latex?p_n)更接近y值的结论，所以我们只需把p的下标增大点就可以无限接近y了。

带入到原式子可以得到，k = 0.5*(k + n/k)

k代表的就是p，n代表的就是x。

### 洗牌算法

### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

#### 方法 1：暴力

**直观想法**

直接按问题描述进行。对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值

```c++
int trap(vector<int>& height)
{
    int ans = 0;
    int size = height.size();
    for (int i = 1; i < size - 1; i++) {
        int max_left = 0, max_right = 0;
        for (int j = i; j >= 0; j--) { //Search the left part for max bar size
            max_left = max(max_left, height[j]);
        }
        for (int j = i; j < size; j++) { //Search the right part for max bar size
            max_right = max(max_right, height[j]);
        }
        ans += min(max_left, max_right) - height[i];
    }
    return ans;
}
```

优化，先保存下左右的最大值

```c++
int trap(vector<int>& height)
{
    if (height == null)
        return 0;
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; i++) {
        left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        right_max[i] = max(height[i], right_max[i + 1]);
    }
    for (int i = 1; i < size - 1; i++) {
        ans += min(left_max[i], right_max[i]) - height[i];
    }
    return ans;
}
```

#### 方法 2：使用双指针

使用双指针优化上面的``left_max``和``right_max``数组

和上面的方法相比，我们不从左和从右分开计算，我们想办法一次完成遍历。
从动态编程方法的示意图中我们注意到，只要${right\_max}[i]>{left\_max}[i]$，积水高度将由 $left\_max$ 决定，类似地 ${left\_max}[i]>{right\_max}[i]$
所以我们可以认为如果一端有更高的条形块（例如右端），积水的高度依赖于当前方向的高度（从左到右）。当我们发现另一侧（右侧）的条形块高度不是最高的，我们则开始从相反的方向遍历（从右到左）。
所以可以使用两个指针交替进行，实现 1 次遍历即可完成。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.empty())
            return 0;
        int n=height.size();
        int left=0,right=n-1;
        int left_max=height[0],right_max=height[n-1];
        int ans=0;
        while(left<right){
            if(left_max<right_max){
                ans+=left_max-height[left];
                left++;
                left_max=max(height[left],left_max);
            }
            else{
                ans+=right_max-height[right];
                right--;
                right_max=max(height[right],right_max);
            }
        }
        return ans;
    }
};
```



#### 方法 3：单调栈

直观想法

我们可以不用像方法 2 那样存储最大高度，而是用栈来跟踪可能储水的最长的条形块。使用栈就可以在一次遍历内完成计算。

我们在遍历数组时维护一个栈。如果当前的条形块小于或等于栈顶的条形块，我们将条形块的索引入栈，意思是当前的条形块被栈中的前一个条形块界定。如果我们发现一个条形块长于栈顶，我们可以确定栈顶的条形块被当前条形块和栈的前一个条形块界定，因此我们可以弹出栈顶元素并且累加答案到 $ans$

```c++

int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
```



## 每日一题

### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```c++
//对原数组排序，然后三层循环，每层循环对重复的数字只取一次（取最前面的）来去重。
//使用双指针优化一层循环
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        vector<vector<int>> ans;
        for(int i=0;i<n-2;i++){
            if(i!=0&&nums[i]==nums[i-1])//只取重复数字的最前面的哪一位
                continue;
            int left=i+1,right=n-1; //双指针优化一层循环
            while(left<right){
                if(left!=i+1&&nums[left]==nums[left-1]){
                    left++;
                    continue;
                }
                if(right!=n-1&&nums[right]==nums[right+1]){
                    right--;
                    continue;
                }
                int sum=nums[i]+nums[left]+nums[right];
                if(sum==0){
                    ans.push_back({nums[i],nums[left],nums[right]});
                    left++;
                    right--;
                }
                else if(sum>0){
                    right--;
                }
                else{
                    left++;
                }

            }
        }
        return ans;
    }
};
```

### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```c++
//一趟扫描，用两个指针指向0和1的末尾
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int p0=0,p1=0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==1){
                swap(nums[i],nums[p1]);
                p1++;
            }
            else if(nums[i]==0){
                swap(nums[i],nums[p0]);
                if(p0<p1){      //这时候swap会把一个1交换i处，只需要把1再交换回来即可
                    swap(nums[i],nums[p1]);
                }
                p0++;
                p1++;
            }
        }
    }
};
```

```c++
//两趟扫描，第一趟记录三种颜色的数目，第二趟赋值就完了
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int red=0,white=0,blue=0;
        for(int n:nums){
            if(n==0)
                red++;
            else if(n==1)
                white++;
            else
                blue++;
        }
        for(int i=0;i<nums.size();i++){
            if(i<red)
                nums[i]=0;
            else if(i<white+red)
                nums[i]=1;
            else
                nums[i]=2;
        }
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* newHead=head->next;
        head->next=swapPairs(newHead->next);
        newHead->next=head;
        return newHead;
    }
};
```

### [1002. 查找常用字符](https://leetcode-cn.com/problems/find-common-characters/)

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<int> minfreg(26,INT_MAX);
        vector<int> freg(26,0);
        for(auto str:A){
            fill(freg.begin(),freg.end(),0);
            for(char c:str){
                freg[c-'a']++;
            }
            for(int i=0;i<26;i++)
                minfreg[i]=min(minfreg[i],freg[i]);
        }
        vector<string> ans;
        for(int i=0;i<26;i++)
            for(int j=0;j<minfreg[i];j++)
                ans.emplace_back(1,i+'a');
        return ans;
    }
};
```



## 待解决

二叉树的非递归遍历

c++的rand()函数